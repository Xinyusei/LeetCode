框架

1、明确 `dp` 数组的定义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。

2、根据 `dp` 数组的定义，运用数学归纳法的思想，假设 `dp[0...i-1]` 都已知，想办法求出 `dp[i]`，一旦这一步完成，整个题目基本就解决了。

但如果无法完成这一步，很可能就是 `dp` 数组的定义不够恰当，需要重新定义 `dp` 数组的含义；

或者可能是 `dp` 数组存储的信息还不够，不足以推出下一步的答案，需要把 `dp` 数组扩大成二维数组甚至三维数组。

## 经典线性DP

### 最长递增子序列LIS

#### 板子-300.最长递增子序列

```java
package Type_.动态规划.经典线性DP.最长递增子序列LIS;

import java.util.Arrays;

/**
 * 300. 最长递增子序列
 * https://leetcode.cn/problems/longest-increasing-subsequence/description/
 * 2024-6-17
 */
public class a300最长递增子序列 {
    class Solution {
        public int lengthOfLIS(int[] nums) {
            int n = nums.length;
            int[] f = new int[n];
            //f[i] 表示以nums[0~i]的子序列且以nums[i]结尾的最长递增子序列的长度
            Arrays.fill(f, 1);
            int ret = 1;
            for (int i = 1; i < n; i++) {
                for (int j = 0; j < i; j++) {
                    if (nums[i] > nums[j])
                        f[i] = Math.max(f[i], f[j] + 1);
                }
                ret = Math.max(ret, f[i]);
            }
            System.out.println(Arrays.toString(f));
            return ret;
        }
    }
}

```



### 最长公共子序列

#### Hard.115.不同的子序列

```java
package Type_.动态规划.经典线性DP.最长公共子序列LCS;

/**
 * 115. 不同的子序列
 * https://leetcode.cn/problems/distinct-subsequences/description/
 * 2024-6-17
 */
public class a115不同的子序列 {
    class Solution {
        static final int MOD = (int) 1e9 + 7;

        public int numDistinct(String s, String t) {
            int m = s.length(), n = t.length();
            if (m < n)
                return 0;
            int[][] f = new int[m + 1][n + 1];
            //f[i][j]  定义 f[i][j] 为考虑 s 中 [0~i - 1] 个字符，t 中 [0~j - 1] 个字符的匹配个数。
            //base case
            for (int i = 0; i <= m; i++)
                f[i][0] = 1;

            for (int i = 1; i <= m; i++) {
                for (int j = 1; j <= n; j++) {
                    //两种决策
                    //1.不让s[i]参与匹配 则 f[i][j] = f[i - 1][j]
                    f[i][j] = f[i - 1][j];
                    //2.让s[i]参与匹配, 则要求s[i] == t[j]
                    //s[i] = t[j]
                    if(s.charAt(i - 1) == t.charAt(j - 1)){
                        f[i][j] += f[i - 1][j - 1];
                    }
                }
            }
            return f[m][n];
        }
    }
}

```

> 总结
> 关于字符串匹配，通常有两种（你也可以理解为一种）通用的状态定义：
>
> ```bash
> 1. f[i][j] 表示第一个字符s中[0~i - 1]与t中[0~j - 1]的匹配结果
> 
> 2. f[i][j] 表示第一个字符s中[0~i - 1]与t中[0~j - 1] 且 最后一个字符串为t[j] 的匹配结果
> ```
>
> 
>
> 作者：宫水三叶
> 

## 背包问题

### 0-1背包

#### 基本



![image-20240604151046229](./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/0-1%E8%83%8C%E5%8C%85-1.png)

##### Code

```java
class Solution1 {
    /**
     * 给你一个可装载重量为 capacity 的背包和 n 个物品,每个物品有重量和价值两个属性。
     * 其中第 i 个物品的重量为 w[i] ,价值为 v[i] ,现在让你用这个背包装物品,最多能装的价值是多少?
     * n = 3, capacity = 4
     * w = [2, 1, 3]
     * v = [4, 2, 3]
     *
     * @param v        第i个物品的价值
     * @param w        第i个物品的体积
     * @param capacity 背包容量
     * @return 在不超过背包容量的情况下，背包中放入的物品的最大价值
     */

    int[] v;

    int[] w;

    int capacity;

    public int zero_one_knapsack(int[] v, int[] w, int capacity) {
        this.v = v;
        this.w = w;
        this.capacity = capacity;

        return dfs(capacity, v.length - 1);
    }

    /**
     * @param capacity 当前背包的容量
     * @param i        当前是第几个物品
     * @return 在不超过capacity容量的情况下, 在前i个物品中加入了背包的物品的最大价值
     */

    private int dfs(int capacity, int i) {
        if (i < 0)
            return 0;
        if (capacity < w[i])
            return dfs(capacity, i - 1);
        //当前操作 ： 枚举当前物品，选/不选
        //选:在容量为capacity - w[i],从前i - 1个物品中得到的最大价值和
        //不选:在容量为capacity,从前i - 1个物品中得到的最大价值和
        return Math.max(dfs(capacity - w[i], i - 1) + v[i], dfs(capacity, i - 1));
    }
}


class Solution2 {
    /**
     * 给你一个可装载重量为 capacity 的背包和 n 个物品,每个物品有重量和价值两个属性。
     * 其中第 i 个物品的重量为 w[i] ,价值为 v[i] ,现在让你用这个背包装物品,最多能装的价值是多少?
     * n = 3, capacity = 4
     * w = [2, 1, 3]
     * v = [4, 2, 3]
     *
     * @param v        第i个物品的价值
     * @param w        第i个物品的体积
     * @param capacity 背包容量
     * @return 在不超过背包容量的情况下，背包中放入的物品的最大价值
     */
    public int zero_one_knapsack(int[] v, int[] w, int capacity) {
        int n = v.length;
        int[][] f = new int[n + 1][capacity + 1];
        //定义：f[i][c] 的定义如下：对于前 i 个物品，当前背包的容量为 c，这种情况下可以装的最大价值是 dp[i][c]。
        //比如说，如果 f[3][5] = 6，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。
        //注意这里的下标i从(1)开始,表示从前(1)个物品开始取。
        for (int i = 1; i <= n; i++) {
            for (int c = w[i]; c <= capacity; c++) {
                //如果把这第 i 个物品装入了背包，那么第 i 个物品的价值 val[i-1] 肯定就到手了
                //接下来就要在剩余容量 c - w[i-1] 的限制下，在前 i - 1 个物品中挑选，求最大价值，即 f[i-1][c - w[i-1]]。
                //f[i][c] 应该等于  f[i-1][c - w[i-1]] + v[i-1]。
                //如果没有把这第 i 个物品装入背包，那么很显然，最大价值 f[i][c] 应该等于 f[i-1][w]，继承之前的结果。
                f[i][c] = Math.max(f[i - 1][c - w[i - 1]] + v[i - 1],f[i - 1][c]);
            }
        }
        return f[n][capacity];
    }
}


```





#### 常见变形

![image-20240604153612813](./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/0-1%E8%83%8C%E5%8C%85-%E5%B8%B8%E8%A7%81%E5%8F%98%E5%BD%A2.png)



##### 1. 恰好-目标和

```java
/**
 * 494. 目标和
 * https://leetcode.cn/problems/target-sum/description/
 */

public class a494目标和 {
    class Solution {
        public int findTargetSumWays(int[] nums, int t) {
            //x , sum - x
            //x - sum + x = target
            //x = (sum + target) / 2
            
            int sum = 0;
            int n = nums.length;
            for (int num : nums)
                sum += num;
            int target = sum + t;
            if (target < 0 || target % 2 != 0)
                return 0;
            target >>= 1;
            //f[i][w] 表示从前 i 个数中选出几个数,其和为 w 的方法数
            int[][] f = new int[n + 1][target + 1];
            f[0][0] = 1;
            for (int i = 1; i <= n; i++) {
                for (int w = 0; w <= target; w++) {
                    //第i个数选：子问题变为从前i - 1个数中选出几个数,其和为w-nums[i - 1]的方法数
                    //第i个数不选:子问题变为从前i - 1个数中选出几个数,其和为w的方法数
                    if (w < nums[i - 1])
                        f[i][w] = f[i - 1][w];
                    else
                        f[i][w] = f[i - 1][w - nums[i - 1]] + f[i - 1][w];
                }
            }
            return f[n][target];
        }
    }
}
```

