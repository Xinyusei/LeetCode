框架

1、明确 `dp` 数组的定义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。

2、根据 `dp` 数组的定义，运用数学归纳法的思想，假设 `dp[0...i-1]` 都已知，想办法求出 `dp[i]`，一旦这一步完成，整个题目基本就解决了。

但如果无法完成这一步，很可能就是 `dp` 数组的定义不够恰当，需要重新定义 `dp` 数组的含义；

或者可能是 `dp` 数组存储的信息还不够，不足以推出下一步的答案，需要把 `dp` 数组扩大成二维数组甚至三维数组。

## 子序列问题

### 最长递增子序列

```java
package Type_.滑动窗口;

import java.util.Arrays;

public class a300最长递增子序列 {
    public int lengthOfLIS(int[] nums) {

        int res = 1, n = nums.length;

        //dp[i]表示以nums[i]结尾的最长递增子序列的长度
        int[] dp = new int[n];

        //假设已经知道dp[0~4] 如何去找dp[5]
        for (int i = 0; i < n; i++) {
            //base case
            dp[i] = 1;
            for (int j = 0; j < i; j++) {
                //寻找nums[0~j-1]中比nums[i]小的元素
                if (nums[j] < nums[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            if(dp[i] > res)
                res = dp[i];
        }
        //debug
//        for (int i = 0; i < dp.length; i++) {
//            System.out.print(dp[i] + " ");
//        }

        return res;
    }
}
```



## 背包问题

### 0-1背包

#### 基本



![image-20240604151046229](./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/0-1%E8%83%8C%E5%8C%85-1.png)

##### Code

```java
class Solution1 {
    /**
     * 给你一个可装载重量为 capacity 的背包和 n 个物品,每个物品有重量和价值两个属性。
     * 其中第 i 个物品的重量为 w[i] ,价值为 v[i] ,现在让你用这个背包装物品,最多能装的价值是多少?
     * n = 3, capacity = 4
     * w = [2, 1, 3]
     * v = [4, 2, 3]
     *
     * @param v        第i个物品的价值
     * @param w        第i个物品的体积
     * @param capacity 背包容量
     * @return 在不超过背包容量的情况下，背包中放入的物品的最大价值
     */

    int[] v;

    int[] w;

    int capacity;

    public int zero_one_knapsack(int[] v, int[] w, int capacity) {
        this.v = v;
        this.w = w;
        this.capacity = capacity;

        return dfs(capacity, v.length - 1);
    }

    /**
     * @param capacity 当前背包的容量
     * @param i        当前是第几个物品
     * @return 在不超过capacity容量的情况下, 在前i个物品中加入了背包的物品的最大价值
     */

    private int dfs(int capacity, int i) {
        if (i < 0)
            return 0;
        if (capacity < w[i])
            return dfs(capacity, i - 1);
        //当前操作 ： 枚举当前物品，选/不选
        //选:在容量为capacity - w[i],从前i - 1个物品中得到的最大价值和
        //不选:在容量为capacity,从前i - 1个物品中得到的最大价值和
        return Math.max(dfs(capacity - w[i], i - 1) + v[i], dfs(capacity, i - 1));
    }
}


class Solution2 {
    /**
     * 给你一个可装载重量为 capacity 的背包和 n 个物品,每个物品有重量和价值两个属性。
     * 其中第 i 个物品的重量为 w[i] ,价值为 v[i] ,现在让你用这个背包装物品,最多能装的价值是多少?
     * n = 3, capacity = 4
     * w = [2, 1, 3]
     * v = [4, 2, 3]
     *
     * @param v        第i个物品的价值
     * @param w        第i个物品的体积
     * @param capacity 背包容量
     * @return 在不超过背包容量的情况下，背包中放入的物品的最大价值
     */
    public int zero_one_knapsack(int[] v, int[] w, int capacity) {
        int n = v.length;
        int[][] f = new int[n + 1][capacity + 1];
        //定义：f[i][c] 的定义如下：对于前 i 个物品，当前背包的容量为 c，这种情况下可以装的最大价值是 dp[i][c]。
        //比如说，如果 f[3][5] = 6，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。
        //注意这里的下标i从(1)开始,表示从前(1)个物品开始取。
        for (int i = 1; i <= n; i++) {
            for (int c = w[i]; c <= capacity; c++) {
                //如果把这第 i 个物品装入了背包，那么第 i 个物品的价值 val[i-1] 肯定就到手了
                //接下来就要在剩余容量 c - w[i-1] 的限制下，在前 i - 1 个物品中挑选，求最大价值，即 f[i-1][c - w[i-1]]。
                //f[i][c] 应该等于  f[i-1][c - w[i-1]] + v[i-1]。
                //如果没有把这第 i 个物品装入背包，那么很显然，最大价值 f[i][c] 应该等于 f[i-1][w]，继承之前的结果。
                f[i][c] = Math.max(f[i - 1][c - w[i - 1]] + v[i - 1],f[i - 1][c]);
            }
        }
        return f[n][capacity];
    }
}


```





#### 常见变形

![image-20240604153612813](./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/0-1%E8%83%8C%E5%8C%85-%E5%B8%B8%E8%A7%81%E5%8F%98%E5%BD%A2.png)



##### 1. 恰好-目标和

```java
/**
 * 494. 目标和
 * https://leetcode.cn/problems/target-sum/description/
 */

public class a494目标和 {
    class Solution {
        public int findTargetSumWays(int[] nums, int t) {
            //x , sum - x
            //x - sum + x = target
            //x = (sum + target) / 2
            
            int sum = 0;
            int n = nums.length;
            for (int num : nums)
                sum += num;
            int target = sum + t;
            if (target < 0 || target % 2 != 0)
                return 0;
            target >>= 1;
            //f[i][w] 表示从前 i 个数中选出几个数,其和为 w 的方法数
            int[][] f = new int[n + 1][target + 1];
            f[0][0] = 1;
            for (int i = 1; i <= n; i++) {
                for (int w = 0; w <= target; w++) {
                    //第i个数选：子问题变为从前i - 1个数中选出几个数,其和为w-nums[i - 1]的方法数
                    //第i个数不选:子问题变为从前i - 1个数中选出几个数,其和为w的方法数
                    if (w < nums[i - 1])
                        f[i][w] = f[i - 1][w];
                    else
                        f[i][w] = f[i - 1][w - nums[i - 1]] + f[i - 1][w];
                }
            }
            return f[n][target];
        }
    }
}

```

